\documentclass[notitlepage, a4paper, 11pt]{scrartcl}

%too much whitespace otherwise
\usepackage[left=23mm,top=20mm,right=23mm,bottom=15mm]{geometry}

% deutsche Übersetzungen
%\usepackage[ngerman]{babel}
% Grafik Pakete
\usepackage{graphicx,hyperref,amssymb}
% Ordner für Grafiken
\graphicspath{ {./images/} }
% Pakete für Formatierung der Grafiken
\usepackage{wrapfig}
\usepackage{float}
% deutsches Encoding (Umlaute)
\usepackage[utf8]{inputenc}
% für Grad Symbol
\usepackage{textcomp}

% Header and Footer
\usepackage{fancyhdr}

\usepackage{titlesec}

%image grid
\usepackage{graphicx}
\usepackage{subfig}

\usepackage{multicol}

\usepackage{cite}

\usepackage{amsmath}

%\geometry{top=20mm}
\usepackage{etoolbox}

\usepackage{hyperref}
\usepackage{cleveref}

\makeatletter
\patchcmd{\@maketitle}{\vskip 2em}{\vspace*{-1cm}}{}{}
\makeatother

% Keywords command
\providecommand{\keywords}[1]
{
  \small	
  \textbf{\textit{Keywords---}} #1
}

\titleformat*{\subsection}{\small\bfseries}

\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage}
\rhead{Lückert, Neudecker}
\lhead{Pool-Predictor - a Kalman-Filter Implementation}
 
\begin{document}

\title{Pool-Predictor - a Kalman-Filter Implementation}
\author{Marlon Lückert B.Sc. - Julius Neudecker B.Sc.}
\date{Feburary 2020}

\maketitle

\begin{abstract}
In this article we are goinbg to discuss an implementation of the Kalman-filter \cite{kalman} to improve measurement quality and predict the movement of balls on a pool table. 
We are going to point out the reasoning why we implemented the filter as a constant velocity model and its weak points in this situation.
Since the performance of the filter deteriorates in cases of a rapid change in direction, we derived two different implementations with adaptive behaviour.
The implementations were tested in a simulator and with real world video footage of a pool table.
We conclude this paper with a performance evaluation of the implementation and provide a proposal to further increase accuracy.

\end{abstract}

\keywords{kalman, pool, prediction, filter}

\begin{multicols}{2}
\section{Introduction}

\subsection{Game of Pool} \label{intro}

At first glance the game of pool is very suitable to examine the behaviour of a kalman-filter enhanced tracking system based on pure visual tracking. 
The surface of a pool table is made of a thin fabric which covers a hard surface i.e. slate or granite.
The balls nowadays are usually made out of resin. This combination of materials creates very small rolling resistance and the balls behave almost fully elastic on collision.
Since this is only a 2 DOF\footnote{Dimensions Of Freedom - determines the possible rotation or translation along each given axis} problem, this can be solved with a simple linear kalman filter implementation. 
The problem is, when two balls hit each other or a cushion the velocity vector changes its orientation instantly. 
If this isn't taken into account, the filter needs some time to adapt to the new direction of movement and will produce wrong estimations during this time.

This behaviour is independent of the type of kalman implementation being CVM or CAM (see \cref{kalman-basic}).
A kalman filter will assume the direction of movement on any given sample is about the same as in the last sample. 
It will therefore create wrong estimations if the directon of movement changes drastically in a short period of time. The time the filter needs to recover depends on the filter gain.

We also use the filter to predict values for any given length into the future by feeding back its estimations as actual state. 
The quality of this prediction however depends on several factors, which we discuss in detail in \cref{implementation}.

\subsection{Visual Recognition of moving elements}

In order to create a state-vector input we have to track the balls on the pool table. 
To provide consistent and reproductable results, we used video footage and processed them with the Python implementation of openCV.
A video example as seen in \cref{pic:pool-color} is put into an instance of simple video-processing steps to create a black and white mask of the ball contours as displayed in \cref{pic:pool-bw},
where the center of the white pixel cluster is the ball we're looking for.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{pool_color.PNG}}
    \caption{color picture of a pool table}
    \label{pic:pool-color}
\end{figure}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{pool_mask.PNG}}
    \caption{contours of balls after processing}
    \label{pic:pool-bw}
\end{figure}

This type of vision based tracking works reliably for our requirements.

\section{Related Work}

In the following section, we are going to discuss some previous work that is related to our work but none of these articles targets the problem in the same manner.

Jong-Yun Kim and Tae-Yong Kim \cite{kim} developed a method to provide robust tracking of a soccer ball. 
They provide a solution for the problem for the case that the soccer ball might be occluded by the player at any given time,
which results in a diminished tracking accuracy. 
In this case they used the velocity vector of the player to substitute for the ball presuming that the ball moves in the same direction as the player does.

Jia et.al. \cite{jia} conducted research in the trajectory of pool balls, which helped us to decide which kalman model is the most suitable.

Shiuh et.al. \cite{shiuh} provided a good starting point how to create a tracking algorithm for pool balls. They also developed an algorithm to track occluded objects using an adaptive kalman filter.
In this case they used to threshhold in order to determine wheter the object can still be reliably tracked. If this isn't the case the filter will rely only on predicted values until the object can be tracked reliably again.

Salzmann and Urtasun \cite{salzmann} proposed a more general approach for tracking. 
They were able to recreate a highly accurate tracking from a noisy picture based on newtons 2nd law and markov models.
Using different constraints and presumptions they were even able to extract physical parameters like friction and trajectories.

Mohamed and Schwarz \cite{schwarz} are using partly the same approach as we do to improve the results created by INS/GPS\footnote{Inertial Navigation System / Global Positioning System} Systems.
However their approach only targets the 'Q' and 'R' parameters of the filter.

Sarkka and Nummenmaa \cite{sarkka} created an adaptive kalman implementation which adapts itself to time-varying noise parameters. Since our input data is constant in this regard,
we decided to simulate for the optimal filter parametrization instead of relying on the filter to adapt itself.

Gabdulkhakova and Kropatsch \cite{kropatsch} use a kalman filter to create a video analysis tool for snooker game broadcasting.

\section{Implementation} \label{implementation}
In this section we're going to discuss the different implementations and their constraints. The filter implementations in section \cref{dynamic-q} and \cref{smart-filter} are derived from
the basic implementation in \cref{kalman-basic}. At the end of this section we will provide a comparison of all filter types and their performance in our simulation.

\subsection{Kalman Filter} \label{kalman-basic}

The basic layout and working mechanism of a kalman filter is in described in detail in \cite{kalman}. 
However in order to fully understand our improvements we provide an introduction to the crucial parts of the kalman filter.

Its purpose is to filter noisy or unreliable sensor data. Its doing this by comparing predictions made based on the model and actual measurements. 
Depending on the filter gain it will use a bigger portion of either. This estimated value represents the actual state of the measured system and is used to make the next estimation.

This is represented in \cref{eq1}

\begin{equation} 
    \label{eq1}
    \hat{x}[n]=\tilde{x}[n]+K*(y[n]-C*\tilde{x}[n])
\end{equation}

Where $K$ represents a factor, which determines the amount of measured values applied to the prediction to create a new estimation. It is defined as in \cref{eq2}, 
where $\tilde{P}[n]$ is the prediction error from the current prediction, $C^T$ is a matrix to map our state vector to our system model and $S$ represents the combined error of estimation error and measurement noise.

\begin{equation} 
    \label{eq2}
    K=\tilde{P}[n]*C^T+S^{-1}
\end{equation}

Every prediction which is used in \cref{eq1}, was previously calculated using the state transition model $A_d$:

\begin{equation} 
    \label{eq3}
    \tilde{x}[n]=A_d*\hat{x}[n-1]
\end{equation}

The important parts for our further development are $A_d$ in \cref{eq3} and $\tilde{P}[n]$ in \cref{eq2}. The state transition matrix $Ad$ defines the motion model of our filter.
There are two principal models which we are going to examine: 
the constant velocity model (CVM) and constant acceleration model (CAM). This determines the state transition matrix $A_d$ and defines the constant component: velocity or acceleration.
The estimation error $\tilde{P}[n]$ is defined in \cref{eq4}:

\begin{equation} 
    \label{eq4}
    \tilde{P}[n]=A_d*\hat{P}[n-1]*A_d^T+G_d*Q*G_d^T
\end{equation}

The element $Q$ is the important part here. It defines the amount of systemnoise in the whole filter process, which we are going to discuss in \cref{dynamic-q}.

\subsection{Dynamic Q-parameters} \label{dynamic-q}

We previously mentioned in \cref{intro}, that the filter can't adapt to sudden changes in direction of the moving object. 
The case where the ball collides with the cushion can be mitigated by choosing a different values for $Q$ in \cref{eq4} within the crucial time window.
Thus the filter relies more on the measurement than the estimations. By doing so it can adapt momentarily.
We implemented a look-up table and constantly check every sample for proximity to a cushion.

\subsection{Smart Filter} \label{smart-filter}

In addition to the previous section we developed another improvement. In this case it can be assumend that the angle of incidence is equal to angle of reflection. 
With this assumption we can now implement the reflection with a single vector-multiplication expression. 

Assuming that we have a velocity vector pointing in the direction of $x$ and $y$, the operation to mirror on the x-axis is as in \cref{eq5}:

\begin{equation} 
    \label{eq5}
    \vec{v}_{mirror} = 
    \left(\!
    \begin{array}{c}
      v_x \\
      v_y
    \end{array}
    \!\right) *
    \left(\!
    \begin{array}{c}
        -1 \\
        1
    \end{array}
    \!\right)
\end{equation}

As in the previous section this operation can be performed, when the ball hits the cushion.


\subsection{Filter performance comparison} \label{perf-comp}

We developed a simulation, where we could test different parameters and scenarios to get consistent results. 
We also used this simulation to determine the optimal value for the process noise in \cref{dynamic-q}. The results are shown in \cref{fig:sim-results}:

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{filter_comparison_horizontal.PNG}}
    \caption{Performance of different filter implementations for CVM and CAM}
    \label{fig:sim-results}
\end{figure}

The blue column represents the filtered values, which were generated from noisy measurements compared the ground truth. 
The orange column shows how much the prediction 30 frames in the future deviated from the ground truth.
The effect of the dynamic process noise is negligable but the vector mirroring has a large impact on the accuracy on either motion models.
It is especially interesting that the CAM model shows a better performance in this case. 
This is due to the fact this model can be very accurate but is also very sensitive for error.

Another impact the vector mirroring has on the time scale is show in \cref{fig:deviation-noise}:

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{prediction_dyn_smart_time.PNG}}
    \caption{Performance of different filter implementations}
    \label{fig:deviation-noise}
\end{figure}

This figure represents the distance to ground truth over time for the prediction 30 frames in the future. 
The red areas are where the ball is close to the cushion. 
Although the dynamic-q implementation is able to mitigate the overshoot problem, the prediction error rises quickly since the accuracy declines also with a higher process noise.
The smart implementation however delivers constant accuracy regardless of proximity to the cushion.

\section{Simulations}

We simulated this smart implementation of the CVM with different technical parameters to examine its performance for predicting values 15, 30 or 60 frames in the future.
Displayed are each distances from the prediction to the ground truth over the entire simulation.

\subsection{Sampling}

The first simulation altered the sampling-rate. In a real-world scenarion this would be the frame rate of the camera.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{fps_boxplot.PNG}}
    \caption{Impact of framerates on prediction accuracy}
    \label{fig:framerate10}
\end{figure}

The sample rate has a certain impact on the quality of the prediction. However the the difference between 30 and 60 frames is not as big as between 10 and 30. 
This depends greatly on the initial velocity of the ball. The anomaly at 30 frames with a sample rate of 10 fps is caused by the fact that due to the low sample rate 
the filter just misses the point where the ball hits the cusion and isn't able to predict this.

\subsection{Noise}

The second simulation altered the amount of noise on the measurement and how the filter is able to cope with bad input data.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{noise_boxplot.PNG}}
    \caption{Impact of sensor noise on prediction accuracy}
    \label{fig:noise2}
\end{figure}

Although the amount of noise increased fivefold, the median stays almost constant compared to less noisy samples. The min and max values of deviation however change greatly on magnitude.
This is a good indicator that the filter is actually able to work with worse measurements than we used in our simulation and is still able to produce reasonably accurate predictions well into the future.

\subsection{Velocity}

Lastly we tested the impact of different starting velocities, which has an influence of the distance, which the ball rolls between certain sample periods.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{velocity_boxplot.PNG}}
    \caption{Impact of start velocities on prediction accuracy}
    \label{fig:velocity300}
\end{figure}

We can see here that the starting velocity has barely any effect. 
This is what we expected since the sample rate is high enough to give us sufficient data and we simulated different konfigurations in order to achieve the highest accuary possible.

\section{Results with real footage}

After evaluating that our filter works well within the simulation we tested it on real footage. 
It performed as expected in the footage and gave reasonable good predictions.

However because of imperfections in the tracking alorithm such as deviation what the center of the ball is and changing noise levels in the measurement, 
the filter can't perform as good as in the simulation. Also the reflection-angle on the cushion was mathematically perfect in the simulation
but can vary by small margins in a real scenario.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{pool_real.PNG}}
    \caption{Filter test on real footage}
    \label{fig:realfootage}
\end{figure}

Apart from the simulation we did not have data for the ground truth in this case. 
The quality of the filter can solely be measured by the quality of its prediction. 

As in \cref{perf-comp} mentioned, the CAM model is very sensitive to error. This gets very apparend in real world footage with the MSE (for the prediction of the next 30 frames) of the CVM is only 15.39dB compared to CAM with 21.01dB.

\section{Improvements}

An inherent problem with the nature of sampled values is that there is no prediction or estimation
of the behaviour in between to sample points. It is reasonable to assume that the behavior between
two sample points can be interpolated. But since this problem has edge cases, this more complicated.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{prediction_error.PNG}}
    \caption{Ball hits cushion between two sample points}
    \label{fig:edge-case}
\end{figure}

As seen on \cref{fig:edge-case} the collision between the ball and the cushion is happens between sample 1 and 2. The code detects this and turns the velocity vector as described in \cref{smart-filter}.
By the time of sample 3 the velocity vector points in the right direction but with a small offset error. The correct solution however is shown in \cref{fig:edge-case-sol}:
The overshoot of sample 2 is corrected and mirrored on the point of collision, which affects the following samples. This has a large positive impact on prediction accuracy as well as filter error.

Our current version of the implementation does not has this correction yet but this could be implemented in the future.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.47\textwidth]{prediction_correction.PNG}}
    \caption{Collision correction}
    \label{fig:edge-case-sol}
\end{figure}

\section{Acknowledgement}

We would like to thank Prof. Edeler for his input during the lecture which really helped to further develop the idea.

\end{multicols}

\bibliography{references} 
\bibliographystyle{ieeetr}

\end{document}